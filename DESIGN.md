# Project Design

Overview of the game: This is a game where the player is spawned at a fixed location in the middle of the map. The player’s objective is to explore the area and find where home is. There are many static objects like trees and rocks in the map, which the player cannot directly cross. When the game first begins, the home would be randomly generated at one of four possible locations. Enemies will also be spawned at numerous spawn points in the map. The enemies’ objective is to approach and collide with the player, and when this happens the player would lose health (the player starts off with 5 hearts as health). There are also 3 different types of enemies, fast and small damage ones, slow and large damage ones, and normal ones. When each enemy is spawned, it is randomly assigned one of these three types, so they could move really quickly but only deal 1 heart damage at a time, or they move slow but deal more than 1 heart for damage. There are also health packs scattered around the map, and if the player loses health, they can regain 1 heart each time they find a health pack.

File organization: The project is organized into several python scripts: main.py, player.py, sprites.py, groups.py, screens.py, settings.py, and utils.py. The main script handles the game loop by initializing and running the game, and it also controls all of the logic behind the execution of the game. The player script controls player movement in the game (as the user presses on arrow keys, the player–Jack–would move in 4 different directions). It also handles the corresponding pixelated animation of the player that would be rendered, such as showing the leftward walking image if Jack is walking left. The sprites script contains reusable sprite classes for every non-player object in the game (e.g. the laser shooter, the enemies, the static trees and rocks, the home, the health pack, etc). These classes set the image, size, and other applicable characteristics of each sprite (such as movement and speed for enemies). The groups script places all the sprite classes into one group, and handles the rendering of the game by ensuring that the player’s position is set as the center of the screen, and the camera, or game screen, moves with the player. The screens script handles non-game-playing screens by creating classes for the start screen, won screen, and game over screen, and it also creates a class for interactive buttons that allow users to start or quit the game. The settings script defines parameters like the window size, and it imports modules that’d be used in all other scripts like the pygame library and necessary functions for accessing folders. This abstracts away the need for repetitive imports in the other scripts. The utils script is another tool for abstraction, since it contains a helper function that helps in loading image files.

The design of the main script will now be discussed in detail in the following paragraphs. Main.py first initializes the pygame modules and creates a game window. Next, a sprite group is created for each type of sprites that would behave in similar ways. For example, the trees and rocks are grouped in one because they are all static sprites that simply act as obstacles in the player’s path. The bullets from the laser shooter are one group since they have the unique characteristic of moving at a specific speed and causing enemy death once collided. The enemies are in one group because they exhibit the behavior of approaching the player and causing the player to lose health if collided.  

For the next part, variables are initialized that control the mechanics and state of the game. Since how the game will happen depends on the player’s health, whether the player is trying to shoot, whether the player is taking on damage from the enemy, etc, variables are set to control the execution of later functions. For example, the player’s health is initialized to 5, the player is set to “can take damage”, a damage cooldown variable is set to 500 (such that right after the player loses one heart, there is a 0.5 second cooldown before the next time he can take on damage, which makes the game easier to play). The max health is set to 5 (which is later used to determine whether the player can intake a health packet or not). The collision_damage_delay is set to 1000, meaning that if the player collides with an enemy for longer than 1 second, a health damage would be applied. A game_won variable is set to false to track the state of the game, which is used later when rendering the won game screen. A pygame event is also created and called on every 2 seconds, which spawns a new enemy in the map every time it’s called.

Next, in the load images function, all images used in the game are loaded and scaled accordingly, using the function get_asset_path that was abstracted away into the utils.py script. Pygame’s methods like convert_alpha is used to optimize images to be drawn faster on the screen. Some design decisions include using a dictionary to store the health images (there are 5 images, corresponding to the 5 different health levels the player can have from 1 to 5 hearts). In this dictionary, the keys are 1, 2, 3, 4, 5, and the values are each heart image. This allows easy access of a specific image when the player’s health level changes.

Next, the player frames (moving down, up, left, and right) are loaded as images. These are stored in a dictionary that can be then used by the Player class for animating the player, and this avoids the need to reload images every time the player is moving a certain way (which would cause the game to run very slowly). In a similar way, the enemy animation frames are also loaded, so that the frames can be cycled through quickly during gameplay.

Next, in the input function, the if statement checks if the user has clicked the left mouse and whether the can_shoot variable is set to true. If so, a bullet is spawned 50 pixels in front of the gun (so it looks like it’s coming out of the laser shooter tip), and flies in the direction pointed to by the vector of where the shooter is aiming. The can_shoot variable is then set to false, and a time counter will start (so that the player would only be able to shoot again after the cooldown). The gun_timer function defined below sets the can_shoot variable to true once the time counter exceeds the cooldown time.

Next, the setup function loads the Tiled map along with the layers and objects that were added through the Tiled application, including the objects layer, ground layer, health layer, and entities layer. The collision layer was edited in Tiled, and it contains rectangles invisible in-game, but help block the player from navigating in certain regions (lie out of the map)---this is made possible by adding the sprites in the collision layer only to the collision_sprites group, not the all_sprites group, so they only act as blockages and are not drawn.
The objects layer contain all the static sprites that do not have an influence on the execution of the game but can block player and enemy movement, including the trees, rocks, etc. It is added to both the collision_sprites group and all_sprites group.
The healthpack layer loads in the healthpack objects, which are added to a unique class since the player interacts with healthpacks differently than with enemies. They’re also added to all_sprites to be displayed on screen.

The entities layer is then loaded, spawning the player, gun, home, and adds coordinates to the spawn positions (which will later be used as positions for enemy spawn points). For the home, for example, the code adds all the x, y coordinates for all the spawn positions of home as indicated through Tiled into a list of coordinates. It then chooses a random position out of the list in each round and generates the home at that location.

Next, the bullet_collision function checks if bullets are colliding with enemies and with static sprite / obstacles. If it’s colliding with obstacles like trees, rocks, or borders, the bullet is removed from game. If the bullet collided with an enemy, the destroy method is called on all colliding enemy sprites, and the bullet is also removed from the game. The function to check if the wave is complete (defined as having all enemies in the number set in the wave being destroyed) is also called on, and if that wave is complete, the next wave would begin and there would be 5 more enemies added to the total number in each wave. Furthermore, the enemies would be spawned faster in each future wave.

Next, the player_collision function handles collisions by checking if player is colliding with the enemy. If so, it start a timer, and if that collision time exceeds the pre-set time limit, player takes a health damage. If the player ever collides with home, the game_won state would be set to true and the game wouldn’t run anymore. If the player collides with a health pack, given that the player’s health isn’t at maximum, the health pack would disappear and player health will increase by 1. Right after the player takes damage, a timer begins to make sure the player can’t take another damage within the pre-set cooldown time.

Then, the run function runs the entire game. It starts by showing the start screen, and if the user clicks the start game button, the game begins. Enemies are spawned at spawn points, each enemy’s property of being fast, normal, slow and the amount of damage they can deal is randomly chosen. After event processing, update functions are called. Specifically, the gun_timer manages shooting cooldown, damage_timer manages how long the player is invincible, input() handles user input like shooting, all_sprites.update(dt) updates all sprite positions and animations. Then collision detection functions are called: bullet_collision(), player_collision(), home_collision(), and health_pack_collision(). Sprites are then rendered.

When the game loop is exited, game_won is checked to see if the game has been won, and if so, the win screen is displayed. Overwise, the game over screen is shown. In either case, play_again is a boolean that would be returned to see if the player wants to play again, and if so, reset_game is called. The reset game would reset all the variables used and start a new game.

Sources:

Player images were taken from here: [https://shana_waffles.artstation.com/projects/Pe4Zln]

Enemy images were taken from here: [https://www.youtube.com/channel/UCznj32AM2r98hZfTxrRo9bQ/about]
